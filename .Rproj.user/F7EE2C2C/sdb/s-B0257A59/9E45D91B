{
    "contents" : "## cachematrix.R\n## author: sjchan-ds (gitHub username)\n## Matrix inversion is very costly computation. It should have advantages if ithe inverse\n## matrix is stored rather than compute it repeatedly.\n## The following two functions are for storing the calucated value of an inverse matrix\n## in a cache to avoid recalcuating it repeatedly.\n\n###########################################################################################\n## makecacheMatrix function creates a special \"matrix\" object, which is a list containing \n##   four clousure functions that are for: setting the value of the matrix; getting the value \n##   of the matrix; set the value of the inverse matrix and getting the value of the mean\n##\nmakeCacheMatrix <- function(x = matrix()) {\n     ##definitions of  local variables\n     ## invM: the inverse matrix that is stored in the cache\n     ## x, y: input matrix\n  \n     invM <- NULL    # define and initiate invM\n     \n     set <- function(y) { #set function for setting value of input matrix\n         x <<- y          ## store the input matrix into the cache\n         invM <<- NULL    ## initiate invM \n     } ##end of set function\n     \n     get <- function(){ #get function for getting value of input matrix\n         x              ## get the stored matrix \n     }    \n     \n     setinvMatrix <- function(invMatrix){  #setinvMatrix function\n         invM <<- invMatrix    #store the calculated inverse matrix into cache\n     }\n     \n     getinvMatrix <- function() {   #getinvMatrix fucntion\n       invM                    # get the stored inverse matrix from cache\n     }\n     \n     ##return a list of closure functions\n     list(set = set, get = get, setinvMatrix = setinvMatrix, getinvMatrix = getinvMatrix)\n  \n} ## end of makeCacheMatrix function\n\n###########################################################################################\n## The cacheSolve function calculates the inverse matrix of the special \"matrix\" created \n## from the makeCacheMatrix function. \n## However, the cacheSolve function first checks whether the inverse matrix has already been \n## calculated. If so, it gets the stored value of inverse matrix from the cache via the \n## getinvMatrix function and skips the calculation. \n## Otherwise, it calculates the inverse matrix and then sets the value of the inverse matrix\n##   into the cache via the setinvMatrix function.\n##\ncacheSolve <- function(x, ...) {\n        ## definition of local variables:\n        ## invM: the inverse matrix that is stored in the cache\n        ## data: value of the given matrix\n  \n        invM <- x$getinvMatrix()   \n        if(!is.null(invM)) {  # check whether inverse matrix has been caculated and stored in cache \n              # the value of the inverse matrix is in cache\n              message(\"Getting cached data\")  # print a message \n              return(invM)                    # return its value that is stored from cache,\n        }                                     # skip the caculation\n        \n        ## the following is for the case: the inverse matrix has NOT been caculated\n        data <- x$get()            ## to get the value of given matrix  \n        message(\"Calculating the inverse matrix\")\n        invM <- solve(data, ...)   ## to calculate the inverse matrix via solve function\n        x$setinvMatrix(invM)       ## to store the calculated value into cache\n        invM                       ## return the calculated value\n        \n} ## end of cachesolve function\n\n",
    "created" : 1398265523136.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "750716950",
    "id" : "9E45D91B",
    "lastKnownWriteTime" : 1398439026,
    "path" : "C:/Users/SJ/ProgrammingAssignment2/cachematrix.R",
    "project_path" : "cachematrix.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}